<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>Class: Net::SCP</title>

	<link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

	<script src="../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>

</head>
<body class="class">

	<div id="metadata">
		<div id="file-metadata">
			<div id="file-list-section" class="section">
				<h3 class="section-header">In Files</h3>
				<div class="section-body">
					<ul>
					
						<li><a href="../lib/net/scp/download_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/net/scp/download.rb">lib/net/scp/download.rb</a></li>
					
						<li><a href="../lib/net/scp/errors_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/net/scp/errors.rb">lib/net/scp/errors.rb</a></li>
					
						<li><a href="../lib/net/scp/upload_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/net/scp/upload.rb">lib/net/scp/upload.rb</a></li>
					
						<li><a href="../lib/net/scp/version_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/net/scp/version.rb">lib/net/scp/version.rb</a></li>
					
						<li><a href="../lib/net/scp_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
							class="thickbox" title="lib/net/scp.rb">lib/net/scp.rb</a></li>
					
					</ul>
				</div>
			</div>

			
		</div>

		<div id="class-metadata">

			<!-- Parent Class -->
			
			<div id="parent-class-section" class="section">
				<h3 class="section-header">Parent</h3>
				
				<p class="link">Object</p>
				
			</div>
			

			<!-- Namespace Contents -->
			
			<div id="namespace-list-section" class="section">
				<h3 class="section-header">Namespace</h3>
				<ul class="link-list">
					
					<li><span class="type">MODULE</span> <a href="SCP/Download.html">Net::SCP::Download</a></li>
					
					<li><span class="type">MODULE</span> <a href="SCP/Upload.html">Net::SCP::Upload</a></li>
					
					<li><span class="type">CLASS</span> <a href="SCP/Error.html">Net::SCP::Error</a></li>
					
					<li><span class="type">CLASS</span> <a href="SCP/Version.html">Net::SCP::Version</a></li>
					
				</ul>
			</div>
			

			<!-- Method Quickref -->
			
			<div id="method-list-section" class="section">
				<h3 class="section-header">Methods</h3>
				<ul class="link-list">
					
					<li><a href="#M000018">::download!</a></li>
					
					<li><a href="#M000019">::new</a></li>
					
					<li><a href="#M000016">::start</a></li>
					
					<li><a href="#M000017">::upload!</a></li>
					
					<li><a href="#M000028">#await_response</a></li>
					
					<li><a href="#M000029">#await_response_state</a></li>
					
					<li><a href="#M000022">#download</a></li>
					
					<li><a href="#M000025">#download!</a></li>
					
					<li><a href="#M000030">#finish_state</a></li>
					
					<li><a href="#M000031">#progress_callback</a></li>
					
					<li><a href="#M000032">#sanitize_file_name</a></li>
					
					<li><a href="#M000026">#scp_command</a></li>
					
					<li><a href="#M000027">#start_command</a></li>
					
					<li><a href="#M000020">#upload</a></li>
					
					<li><a href="#M000021">#upload!</a></li>
					
				</ul>
			</div>
			

			<!-- Included Modules -->
			
			<div id="includes-section" class="section">
				<h3 class="section-header">Included Modules</h3>
				<ul class="link-list">
				
				
					<li><span class="include">Net::SSH::Loggable</span></li>
				
				
				
					<li><a class="include" href="SCP/Download.html">Net::SCP::Download</a></li>
				
				
				
					<li><a class="include" href="SCP/Download.html">Net::SCP::Download</a></li>
				
				
				</ul>
			</div>
			
		</div>

		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="../CHANGELOG_rdoc.html">CHANGELOG.rdoc</a></li>
				
					<li class="file"><a href="../README_rdoc.html">README.rdoc</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../Net.html">Net</a></li>
				
					<li><a href="../Net/SCP.html">Net::SCP</a></li>
				
					<li><a href="../Net/SCP/Download.html">Net::SCP::Download</a></li>
				
					<li><a href="../Net/SCP/Error.html">Net::SCP::Error</a></li>
				
					<li><a href="../Net/SCP/Upload.html">Net::SCP::Upload</a></li>
				
					<li><a href="../Net/SCP/Version.html">Net::SCP::Version</a></li>
				
					<li><a href="../Net/SSH.html">Net::SSH</a></li>
				
					<li><a href="../Net/SSH/Connection.html">Net::SSH::Connection</a></li>
				
					<li><a href="../Net/SSH/Connection/Session.html">Net::SSH::Connection::Session</a></li>
				
					<li><a href="../URI.html">URI</a></li>
				
					<li><a href="../URI/SCP.html">URI::SCP</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1 class="class">Net::SCP</h1>

		<div id="description">
			<p>
<a href="SCP.html">Net::SCP</a> implements the <a href="SCP.html">SCP</a>
(Secure CoPy) client protocol, allowing Ruby programs to securely and
programmatically transfer individual files or entire directory trees to and
from remote servers. It provides support for multiple simultaneous <a
href="SCP.html">SCP</a> copies working in parallel over the same
connection, as well as for synchronous, serial copies.
</p>
<p>
Basic usage:
</p>
<pre>
  require 'net/scp'

  Net::SCP.start(&quot;remote.host&quot;, &quot;username&quot;, :password =&gt; &quot;passwd&quot;) do |scp|
    # synchronous (blocking) upload; call blocks until upload completes
    scp.upload! &quot;/local/path&quot;, &quot;/remote/path&quot;

    # asynchronous upload; call returns immediately and requires SSH
    # event loop to run
    channel = scp.upload(&quot;/local/path&quot;, &quot;/remote/path&quot;)
    channel.wait
  end
</pre>
<p>
<a href="SCP.html">Net::SCP</a> also provides an open-uri tie-in, so you
can use the Kernel#open method to open and read a remote file:
</p>
<pre>
  # if you just want to parse SCP URL's:
  require 'uri/scp'
  url = URI.parse(&quot;scp://user@remote.host/path/to/file&quot;)

  # if you want to read from a URL voa SCP:
  require 'uri/open-scp'
  puts open(&quot;scp://user@remote.host/path/to/file&quot;).read
</pre>
<p>
Lastly, <a href="SCP.html">Net::SCP</a> adds a method to the <a
href="SSH/Connection/Session.html">Net::SSH::Connection::Session</a> class,
allowing you to easily grab a <a href="SCP.html">Net::SCP</a> reference
from an existing <a href="SSH.html">Net::SSH</a> session:
</p>
<pre>
  require 'net/ssh'
  require 'net/scp'

  Net::SSH.start(&quot;remote.host&quot;, &quot;username&quot;, :password =&gt; &quot;passwd&quot;) do |ssh|
    ssh.scp.download! &quot;/remote/path&quot;, &quot;/local/path&quot;
  end
</pre>
<h2>Progress Reporting</h2>
<p>
By default, uploading and downloading proceed silently, without any outword
indication of their progress. For long running uploads or downloads (and
especially in interactive environments) it is desirable to report to the
user the progress of the current operation.
</p>
<p>
To receive progress reports for the current operation, just pass a block to
<a href="SCP.html#M000020">upload</a> or <a
href="SCP.html#M000022">download</a> (or one of their variants):
</p>
<pre>
  scp.upload!(&quot;/path/to/local&quot;, &quot;/path/to/remote&quot;) do |ch, name, sent, total|
    puts &quot;#{name}: #{sent}/#{total}&quot;
  end
</pre>
<p>
Whenever a new chunk of data is recieved for or sent to a file, the
callback will be invoked, indicating the name of the file (local for
downloads, remote for uploads), the number of bytes that have been sent or
received so far for the file, and the size of the file.
</p>

		</div>

		<!-- Constants -->
		

		<!-- Attributes -->
		
		<div id="attribute-method-details" class="method-section section">
			<h3 class="section-header">Attributes</h3>

			
			<div id="session-attribute-method" class="method-detail">
				<a name="session"></a>
				
				<div class="method-heading attribute-method-heading">
					<span class="method-name">session</span><span
						class="attribute-access-type">[R]</span>
				</div>

				<div class="method-description">
				
				<p>
The underlying <a href="SSH.html">Net::SSH</a> session that acts as
transport for the <a href="SCP.html">SCP</a> packets.
</p>
				
				</div>
			</div>
			
		</div>
		

		<!-- Methods -->
		
		<div id="public-class-method-details" class="method-section section">
			<h3 class="section-header">Public Class Methods</h3>

		
			<div id="download--method" class="method-detail ">
				<a name="M000018"></a>

				<div class="method-heading">
				
					<span class="method-name">download!</span><span
						class="method-args">(host, username, remote, local=nil, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Starts up a new <a href="SSH.html">SSH</a> connection using the
<tt>host</tt> and <tt>username</tt> parameters, instantiates a new <a
href="SCP.html">SCP</a> session on top of it, and then begins a download
from <tt>remote</tt> to <tt>local</tt>. If the <tt>options</tt> hash
includes an :ssh key, the value for that will be passed to the <a
href="SSH.html">SSH</a> connection as options (e.g., to set the password,
etc.). All other options are passed to the <a
href="SCP.html#M000018">download!</a> method. If a block is given, it will
be used to report progress (see &#8220;Progress Reporting&#8221;, under <a
href="SCP.html">Net::SCP</a>).
</p>
					

					
					<div class="method-source-code"
						id="download--source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 232</span>
232:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">download!</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
233:       <span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">dup</span>
234:       <span class="ruby-identifier">start</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:ssh</span>) <span class="ruby-operator">||</span> {}) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">scp</span><span class="ruby-operator">|</span>
235:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">scp</span>.<span class="ruby-identifier">download!</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
236:       <span class="ruby-keyword kw">end</span>
237:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="new-method" class="method-detail ">
				<a name="M000019"></a>

				<div class="method-heading">
				
					<span class="method-name">new</span><span
						class="method-args">(session)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Creates a new <a href="SCP.html">Net::SCP</a> session on top of the given
<a href="SSH.html">Net::SSH</a> <tt>session</tt> object.
</p>
					

					
					<div class="method-source-code"
						id="new-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 245</span>
245:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">session</span>)
246:       <span class="ruby-ivar">@session</span> = <span class="ruby-identifier">session</span>
247:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">logger</span> = <span class="ruby-identifier">session</span>.<span class="ruby-identifier">logger</span>
248:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="start-method" class="method-detail ">
				<a name="M000016"></a>

				<div class="method-heading">
				
					<span class="method-name">start</span><span
						class="method-args">(host, username, options={})</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Starts up a new <a href="SSH.html">SSH</a> connection and instantiates a
new <a href="SCP.html">SCP</a> session on top of it. If a block is given,
the <a href="SCP.html">SCP</a> session is yielded, and the <a
href="SSH.html">SSH</a> session is closed automatically when the block
terminates. If no block is given, the <a href="SCP.html">SCP</a> session is
returned.
</p>
					

					
					<div class="method-source-code"
						id="start-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 195</span>
195:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">options</span>={})
196:       <span class="ruby-identifier">session</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">options</span>)
197:       <span class="ruby-identifier">scp</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">session</span>)
198: 
199:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
200:         <span class="ruby-keyword kw">begin</span>
201:           <span class="ruby-keyword kw">yield</span> <span class="ruby-identifier">scp</span>
202:           <span class="ruby-identifier">session</span>.<span class="ruby-identifier">loop</span>
203:         <span class="ruby-keyword kw">ensure</span>
204:           <span class="ruby-identifier">session</span>.<span class="ruby-identifier">close</span>
205:         <span class="ruby-keyword kw">end</span>
206:       <span class="ruby-keyword kw">else</span>
207:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">scp</span>
208:       <span class="ruby-keyword kw">end</span>
209:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="upload--method" class="method-detail ">
				<a name="M000017"></a>

				<div class="method-heading">
				
					<span class="method-name">upload!</span><span
						class="method-args">(host, username, local, remote, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Starts up a new <a href="SSH.html">SSH</a> connection using the
<tt>host</tt> and <tt>username</tt> parameters, instantiates a new <a
href="SCP.html">SCP</a> session on top of it, and then begins an upload
from <tt>local</tt> to <tt>remote</tt>. If the <tt>options</tt> hash
includes an :ssh key, the value for that will be passed to the <a
href="SSH.html">SSH</a> connection as options (e.g., to set the password,
etc.). All other options are passed to the <a
href="SCP.html#M000017">upload!</a> method. If a block is given, it will be
used to report progress (see &#8220;Progress Reporting&#8221;, under <a
href="SCP.html">Net::SCP</a>).
</p>
					

					
					<div class="method-source-code"
						id="upload--source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 218</span>
218:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">upload!</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
219:       <span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">dup</span>
220:       <span class="ruby-identifier">start</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:ssh</span>) <span class="ruby-operator">||</span> {}) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">scp</span><span class="ruby-operator">|</span>
221:         <span class="ruby-identifier">scp</span>.<span class="ruby-identifier">upload!</span>(<span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
222:       <span class="ruby-keyword kw">end</span>
223:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
		</div>
	
		<div id="public-instance-method-details" class="method-section section">
			<h3 class="section-header">Public Instance Methods</h3>

		
			<div id="download-method" class="method-detail ">
				<a name="M000022"></a>

				<div class="method-heading">
				
					<span class="method-name">download</span><span
						class="method-args">(remote, local, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Inititiate a synchronous (non-blocking) download from <tt>remote</tt> to
<tt>local</tt>. The following options are recognized:
</p>
<ul>
<li>:recursive - the <tt>remote</tt> parameter refers to a remote directory,
which should be downloaded to a new directory named <tt>local</tt> on the
local machine.

</li>
<li>:preserve - the atime and mtime of the file should be preserved.

</li>
<li>:verbose - the process should result in verbose output on the server end
(useful for debugging).

</li>
</ul>
<p>
This method will return immediately, returning the
Net::SSH::Connection::Channel object that will support the download. To
wait for the download to finish, you can either call the wait method on the
channel, or otherwise run the <a href="SSH.html">Net::SSH</a> event loop
until the channel&#8217;s active? method returns false.
</p>
<pre>
  channel = scp.download(&quot;/remote/path&quot;, &quot;/local/path&quot;)
  channel.wait
</pre>
					

					
					<div class="method-source-code"
						id="download-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 298</span>
298:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">download</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
299:       <span class="ruby-identifier">start_command</span>(<span class="ruby-identifier">:download</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
300:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="download--method" class="method-detail ">
				<a name="M000025"></a>

				<div class="method-heading">
				
					<span class="method-name">download!</span><span
						class="method-args">(remote, local=nil, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Same as <a href="SCP.html#M000022">download</a>, but blocks until the
download finishes. Identical to calling <a
href="SCP.html#M000022">download</a> and then calling the wait method on
the channel object that is returned.
</p>
<pre>
  scp.download!(&quot;/remote/path&quot;, &quot;/local/path&quot;)
</pre>
<p>
If <tt>local</tt> is nil, and the download is not recursive (e.g., it is
downloading only a single file), the file will be downloaded to an
in-memory buffer and the resulting string returned.
</p>
<pre>
  data = download!(&quot;/remote/path&quot;)
</pre>
					

					
					<div class="method-source-code"
						id="download--source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 313</span>
313:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">download!</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">local</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
314:       <span class="ruby-identifier">destination</span> = <span class="ruby-identifier">local</span> <span class="ruby-value">? </span><span class="ruby-identifier">local</span> <span class="ruby-operator">:</span> <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>
315:       <span class="ruby-identifier">download</span>(<span class="ruby-identifier">remote</span>, <span class="ruby-identifier">destination</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>).<span class="ruby-identifier">wait</span>
316:       <span class="ruby-identifier">local</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">true</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">destination</span>.<span class="ruby-identifier">string</span>
317:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="upload-method" class="method-detail ">
				<a name="M000020"></a>

				<div class="method-heading">
				
					<span class="method-name">upload</span><span
						class="method-args">(local, remote, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Inititiate a synchronous (non-blocking) upload from <tt>local</tt> to
<tt>remote</tt>. The following options are recognized:
</p>
<ul>
<li>:recursive - the <tt>local</tt> parameter refers to a local directory,
which should be uploaded to a new directory named <tt>remote</tt> on the
remote server.

</li>
<li>:preserve - the atime and mtime of the file should be preserved.

</li>
<li>:verbose - the process should result in verbose output on the server end
(useful for debugging).

</li>
<li>:chunk_size - the size of each &#8220;chunk&#8221; that should be sent.
Defaults to 2048. Changing this value may improve throughput at the expense
of decreasing interactivity.

</li>
</ul>
<p>
This method will return immediately, returning the
Net::SSH::Connection::Channel object that will support the upload. To wait
for the upload to finish, you can either call the wait method on the
channel, or otherwise run the <a href="SSH.html">Net::SSH</a> event loop
until the channel&#8217;s active? method returns false.
</p>
<pre>
  channel = scp.upload(&quot;/local/path&quot;, &quot;/remote/path&quot;)
  channel.wait
</pre>
					

					
					<div class="method-source-code"
						id="upload-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 270</span>
270:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">upload</span>(<span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
271:       <span class="ruby-identifier">start_command</span>(<span class="ruby-identifier">:upload</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
272:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="upload--method" class="method-detail ">
				<a name="M000021"></a>

				<div class="method-heading">
				
					<span class="method-name">upload!</span><span
						class="method-args">(local, remote, options={}, &progress)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Same as <a href="SCP.html#M000020">upload</a>, but blocks until the upload
finishes. Identical to calling <a href="SCP.html#M000020">upload</a> and
then calling the wait method on the channel object that is returned. The
return value is not defined.
</p>
					

					
					<div class="method-source-code"
						id="upload--source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 277</span>
277:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">upload!</span>(<span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>)
278:       <span class="ruby-identifier">upload</span>(<span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">progress</span>).<span class="ruby-identifier">wait</span>
279:     <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
		</div>
	
		<div id="private-instance-method-details" class="method-section section">
			<h3 class="section-header">Private Instance Methods</h3>

		
			<div id="await-response-method" class="method-detail ">
				<a name="M000028"></a>

				<div class="method-heading">
				
					<span class="method-name">await_response</span><span
						class="method-args">(channel, next_state)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Causes the state machine to enter the &#8220;await response&#8221; state,
where things just pause until the server replies with a 0 (see <a
href="SCP.html#M000029">await_response_state</a>), at which point the state
machine will pick up at <tt>next_state</tt> and continue processing.
</p>
					

					
					<div class="method-source-code"
						id="await-response-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 368</span>
368:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">await_response</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">next_state</span>)
369:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-identifier">:await_response</span>
370:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:next</span> ] = <span class="ruby-identifier">next_state</span>.<span class="ruby-identifier">to_sym</span>
371:         <span class="ruby-comment cmt"># check right away, to see if the response is immediately available</span>
372:         <span class="ruby-identifier">await_response_state</span>(<span class="ruby-identifier">channel</span>)
373:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="await-response-state-method" class="method-detail ">
				<a name="M000029"></a>

				<div class="method-heading">
				
					<span class="method-name">await_response_state</span><span
						class="method-args">(channel)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
The action invoked while the state machine remains in the &#8220;await
response&#8221; state. As long as there is no data ready to process, the
machine will remain in this state. As soon as the server replies with an
integer 0 as the only byte, the state machine is kicked into the next state
(see <tt><a href="SCP.html#M000028">await_response</a></tt>). If the
response is not a 0, an exception is raised.
</p>
					

					
					<div class="method-source-code"
						id="await-response-state-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 381</span>
381:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">await_response_state</span>(<span class="ruby-identifier">channel</span>)
382:         <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">available</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
383:         <span class="ruby-identifier">c</span> = <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">read_byte</span>
384:         <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;#{c.chr}#{channel[:buffer].read}&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">c</span> <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
385:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:next</span>], <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>] = <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:next</span>]
386:         <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{channel[:state]}_state&quot;</span>, <span class="ruby-identifier">channel</span>)
387:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="finish-state-method" class="method-detail ">
				<a name="M000030"></a>

				<div class="method-heading">
				
					<span class="method-name">finish_state</span><span
						class="method-args">(channel)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
The action invoked when the state machine is in the &#8220;finish&#8221;
state. It just tells the server not to expect any more data from this end
of the pipe, and allows the pipe to drain until the server closes it.
</p>
					

					
					<div class="method-source-code"
						id="finish-state-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 392</span>
392:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">finish_state</span>(<span class="ruby-identifier">channel</span>)
393:         <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">eof!</span>
394:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="progress-callback-method" class="method-detail ">
				<a name="M000031"></a>

				<div class="method-heading">
				
					<span class="method-name">progress_callback</span><span
						class="method-args">(channel, name, sent, total)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Invoked to report progress back to the client. If a callback was not set,
this does nothing.
</p>
					

					
					<div class="method-source-code"
						id="progress-callback-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 398</span>
398:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">progress_callback</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">sent</span>, <span class="ruby-identifier">total</span>)
399:         <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:callback</span>].<span class="ruby-identifier">call</span>(<span class="ruby-identifier">channel</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">sent</span>, <span class="ruby-identifier">total</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:callback</span>]
400:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="sanitize-file-name-method" class="method-detail ">
				<a name="M000032"></a>

				<div class="method-heading">
				
					<span class="method-name">sanitize_file_name</span><span
						class="method-args">(file_name)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p class="missing-docs">(Not documented)</p>
					

					
					<div class="method-source-code"
						id="sanitize-file-name-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 402</span>
402:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">sanitize_file_name</span>(<span class="ruby-identifier">file_name</span>)
403:         <span class="ruby-identifier">file_name</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp re">/[ ]/</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;\\#{m}&quot;</span> }
404:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="scp-command-method" class="method-detail ">
				<a name="M000026"></a>

				<div class="method-heading">
				
					<span class="method-name">scp_command</span><span
						class="method-args">(mode, options)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Constructs the scp command line needed to initiate and <a
href="SCP.html">SCP</a> session for the given <tt>mode</tt> (:upload or
:download) and with the given options (:verbose, :recursive, :preserve).
Returns the command-line as a string, ready to execute.
</p>
					

					
					<div class="method-source-code"
						id="scp-command-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 325</span>
325:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">scp_command</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">options</span>)
326:         <span class="ruby-identifier">command</span> = <span class="ruby-value str">&quot;scp &quot;</span>
327:         <span class="ruby-identifier">command</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">mode</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">:upload</span> <span class="ruby-operator">?</span> <span class="ruby-value str">&quot;-t&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-value str">&quot;-f&quot;</span>)
328:         <span class="ruby-identifier">command</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; -v&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:verbose</span>]
329:         <span class="ruby-identifier">command</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; -r&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:recursive</span>]
330:         <span class="ruby-identifier">command</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; -p&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:preserve</span>]
331:         <span class="ruby-identifier">command</span>
332:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
			<div id="start-command-method" class="method-detail ">
				<a name="M000027"></a>

				<div class="method-heading">
				
					<span class="method-name">start_command</span><span
						class="method-args">(mode, local, remote, options={}, &callback)</span>
					<span class="method-click-advice">click to toggle source</span>
				
				</div>

				<div class="method-description">
					
					<p>
Opens a new <a href="SSH.html">SSH</a> channel and executes the necessary
<a href="SCP.html">SCP</a> command over it (see <a
href="SCP.html#M000026">scp_command</a>). It then sets up the necessary
callbacks, and sets up a state machine to use to process the upload or
download. (See <a href="SCP/Upload.html">Net::SCP::Upload</a> and <a
href="SCP/Download.html">Net::SCP::Download</a>).
</p>
					

					
					<div class="method-source-code"
						id="start-command-source">
<pre>
     <span class="ruby-comment cmt"># File lib/net/scp.rb, line 338</span>
338:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">start_command</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">local</span>, <span class="ruby-identifier">remote</span>, <span class="ruby-identifier">options</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
339:         <span class="ruby-identifier">session</span>.<span class="ruby-identifier">open_channel</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">channel</span><span class="ruby-operator">|</span>
340:           <span class="ruby-identifier">command</span> = <span class="ruby-node">&quot;#{scp_command(mode, options)} #{sanitize_file_name(remote)}&quot;</span>
341:           <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">exec</span>(<span class="ruby-identifier">command</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">success</span><span class="ruby-operator">|</span>
342:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">success</span>
343:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:local</span>   ] = <span class="ruby-identifier">local</span>
344:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:remote</span>  ] = <span class="ruby-identifier">remote</span>
345:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:options</span> ] = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">dup</span>
346:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:callback</span>] = <span class="ruby-identifier">callback</span>
347:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>  ] = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>
348:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:state</span>   ] = <span class="ruby-node">&quot;#{mode}_start&quot;</span>
349:               <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:stack</span>   ] = []
350: 
351:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_close</span>                  { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;SCP did not finish successfully (#{ch[:exit]})&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">ch</span>[<span class="ruby-identifier">:exit</span>] <span class="ruby-operator">!=</span> <span class="ruby-value">0</span> }
352:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_data</span>                   { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:buffer</span>].<span class="ruby-identifier">append</span>(<span class="ruby-identifier">data</span>) }
353:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_extended_data</span>          { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-identifier">debug</span> { <span class="ruby-identifier">data</span>.<span class="ruby-identifier">chomp</span> } }
354:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_request</span>(<span class="ruby-value str">&quot;exit-status&quot;</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">ch</span>, <span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-identifier">channel</span>[<span class="ruby-identifier">:exit</span>] = <span class="ruby-identifier">data</span>.<span class="ruby-identifier">read_long</span> }
355:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">on_process</span>                { <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{channel[:state]}_state&quot;</span>, <span class="ruby-identifier">channel</span>) }
356:             <span class="ruby-keyword kw">else</span>
357:               <span class="ruby-identifier">channel</span>.<span class="ruby-identifier">close</span>
358:               <span class="ruby-identifier">raise</span> <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SCP</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-value str">&quot;could not exec scp on the remote host&quot;</span>
359:             <span class="ruby-keyword kw">end</span>
360:           <span class="ruby-keyword kw">end</span>
361:         <span class="ruby-keyword kw">end</span>
362:       <span class="ruby-keyword kw">end</span></pre>
					</div>
					
				</div>

				
			</div>

		
		</div>
	

	</div>


	<div id="rdoc-debugging-section-dump" class="debugging-section">
	
		<p>Disabled; run with --debug to generate this.</p>
	
	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>

</body>
</html>

